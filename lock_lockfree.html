<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Courier New";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Courier New";font-style:normal}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c3{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c2"><p class="c5"><span class="c4">Lock&#19982;LockFree&#27973;&#26512;</span></p><p class="c0"><span class="c1">1. Memory Consistency&#21644;Cache Coherence</span></p><p class="c0"><span class="c1">Memory Consistency&#20445;&#35777;&#30340;&#26159;&#21508;&#26465;&#26426;&#22120;&#25351;&#20196;&#23545;&#20869;&#23384;&#30340;&#24433;&#21709;&#39034;&#24207;&#65292;&#31867;&#20284;&#20110;&#25968;&#25454;&#24211;&#30340;&#38548;&#31163;&#32423;&#21035;&#12290;</span></p><p class="c0"><span class="c1">Sequential Consistency&#26159;&#19968;&#31181;Memory Consistency&#65292;&#20445;&#35777;&#20102;&#21508;&#20010;&#32447;&#31243;&#20998;&#21035;&#20197;&#31243;&#24207;&#20013;&#26426;&#22120;&#25351;&#20196;&#30340;&#39034;&#24207;&#24433;&#21709;&#20869;&#23384;&#65292;&#31867;&#20284;&#20110;RC,RR&#31561;&#38548;&#31163;&#32423;&#21035;&#12290;</span></p><p class="c0"><span class="c1">&#32780;x86&#40664;&#35748;&#24773;&#20917;&#19979;&#24182;&#19981;&#33021;&#23436;&#20840;&#36981;&#20174;Sequential Consistency&#12290;&#20250;&#21457;&#29983;&#26080;&#22240;&#26524;&#20851;&#31995;&#30340;Save Load&#20004;&#26465;&#25351;&#20196;&#20081;&#24207;&#25104;&#20026;Load Save&#24341;&#36215;Memory Reorder&#65292;&#36825;&#23545;&#31243;&#24207;&#24615;&#33021;&#26377;&#25552;&#21319;&#65292;&#20294;&#26159;&#22312;&#22810;&#32447;&#31243;&#19979;&#21364;&#21487;&#33021;&#36896;&#25104;&#38750;&#39044;&#26399;&#30340;&#32467;&#26524;&#12290;&#32780;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;&#30340;&#26041;&#24335;&#23601;&#26159;Memory Barrier&#12290;</span></p><p class="c0"><span class="c1">Cache Coherence&#21017;&#25351;&#30340;&#26159;&#22312;&#22810;&#20010;core&#23545;&#20869;&#23384;&#35775;&#38382;&#26102;&#65292;&#23601;&#22909;&#20687;&#30475;&#19981;&#35265;&#22810;&#23618;&#30340;cache&#19968;&#26679;&#65292;&#20445;&#25345;&#20182;&#20204;&#20043;&#38388;&#30340;&#19968;&#33268;&#24615;&#20851;&#31995;&#65292;&#20854;&#20351;&#29992;&#30340;&#30340;&#26159;MESI&#21327;&#35758;&#12290;</span></p><p class="c0"><span class="c1">2. Memory Barrier&#21518;&#38754;&#31616;&#31216;MB</span></p><p class="c0"><span class="c1">MB&#26159;&#19968;&#31181;&#36793;&#30028;&#65292;&#23384;&#22312;&#23427;&#30340;&#22320;&#26041;&#65292;&#19978;&#19979;&#20004;&#26465;&#25351;&#20196;&#30340;&#39034;&#24207;&#19981;&#33021;&#34987;&#20248;&#21270;&#12290;</span></p><p class="c0"><span class="c1">MB&#20998;&#20026;&#20004;&#31181;&#65306;&#19968;&#31181;&#26159;&#32534;&#35793;&#22120;&#32423;&#30340;&#65292;&#19968;&#31181;&#26159;CPU&#32423;&#30340;&#12290;&#32534;&#35793;&#22120;&#32423;&#30340;&#21487;&#20197;&#20445;&#35777;&#29983;&#25104;&#30340;&#20195;&#30721;&#20013;&#19981;&#23384;&#22312;&#20081;&#24207;&#30340;&#21457;&#29983;&#65292;&#20294;&#26159;&#22312;CPU&#25191;&#34892;&#26102;&#36824;&#26159;&#20250;&#20986;&#29616;&#25351;&#20196;&#20081;&#24207;&#30340;&#24773;&#20917;&#12290;CPU&#32423;&#30340;MB&#26263;&#21547;&#20102;&#32534;&#35793;&#22120;&#32423;MB&#30340;&#35821;&#20041;&#65292;&#21516;&#26102;&#20063;&#38450;&#27490;&#20102;CPU&#25191;&#34892;&#26102;&#30340;&#20081;&#24207;&#12290;&#19979;&#38754;&#21015;&#20986;&#20004;&#31181;MB&#30340;&#23454;&#29616;&#65306;</span></p><p class="c0"><span class="c1">#define COMPILER_BARRIER() __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;)</span></p><p class="c0"><span class="c1">#define CPU_BARRIER() __sync_synchronize()</span></p><p class="c0"><span class="c1">&#20540;&#24471;&#19968;&#25552;&#30340;&#26159;&#21407;&#23376;&#25805;&#20316;&#25351;&#20196;&#26159;&#26263;&#21547;CPU&#32423;&#21035;MB&#35821;&#20041;&#30340;&#12290;</span></p><p class="c0"><span class="c1">3. Acquire&#21644;Release&#35821;&#20041;</span></p><p class="c0"><span class="c1">Acquire&#35821;&#20041;&#21487;&#20197;&#20445;&#35777;&#19979;&#38754;&#30340;&#35821;&#21477;&#19981;&#33021;&#34987;&#20081;&#24207;&#21040;&#36825;&#26465;&#35821;&#21477;&#20197;&#19978;&#12290;</span></p><p class="c0"><span class="c1">Release&#35821;&#20041;&#21487;&#20197;&#20445;&#35777;&#19978;&#38754;&#30340;&#35821;&#21477;&#19981;&#33021;&#34987;&#20081;&#24207;&#21040;&#36825;&#26465;&#35821;&#21477;&#20197;&#19979;&#12290;</span></p><p class="c0"><span class="c1">&#19968;&#23545;Acquire&#21644;Release&#21487;&#20197;&#32452;&#25104;&#19968;&#32452;happen-before&#20851;&#31995;&#12290;</span></p><p class="c0"><span class="c1">&#21487;&#20197;&#36731;&#26131;&#30340;&#21457;&#29616;&#65292;&#21152;&#38145;&#21644;&#35299;&#38145;&#25805;&#20316;&#20026;&#20102;&#20020;&#30028;&#21306;&#20195;&#30721;&#19981;&#36867;&#36920;&#23601;&#24517;&#39035;&#20998;&#21035;&#25317;&#26377;Acquire&#21644;Release&#35821;&#20041;&#12290;</span></p><p class="c0"><span class="c1">4. spinlock</span></p><p class="c0"><span class="c1">&#20351;&#29992;&#19968;&#20010;&#21407;&#23376;&#21464;&#37327;&#65292;&#21033;&#29992;CAS&#26426;&#22120;&#25351;&#20196;&#21363;&#21487;&#23454;&#29616;&#19968;&#20010;&#31616;&#21333;&#30340;spinlock&#65292;&#20294;&#36825;&#26679;&#23454;&#29616;&#30340;spinlock&#19981;&#33021;&#36798;&#21040;&#20808;&#26469;&#20808;&#25343;&#38145;&#30340;&#20844;&#24179;&#24615;&#65292;&#20849;&#20139;&#30456;&#21516;&#39640;&#23618;cache&#30456;&#37051;&#30340;core&#20250;&#20248;&#20808;&#24863;&#30693;&#20869;&#23384;&#21464;&#21270;&#65292;&#24456;&#26377;&#21487;&#33021;&#36896;&#25104;&#36825;&#20004;&#20010;core&#20132;&#26367;&#25343;&#38145;&#39295;&#27515;&#20854;&#20182;core&#12290;&#19979;&#38754;&#21015;&#20986;&#20856;&#22411;&#20195;&#30721;&#65306;</span></p><p class="c0"><span class="c1">class SimpleSpinLock {</span></p><p class="c0"><span class="c1">public:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; SimpleSpinLock() :</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic_(0) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void lock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (!(ATOMIC_LOAD(&amp;atomic_) == 0 &amp;&amp; CAS(&amp;atomic_, 0, 1))) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PAUSE();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void unlock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; COMPILER_BARRIER();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; atomic_ = 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">private:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int8_t atomic_;</span></p><p class="c0"><span class="c1">};</span></p><p class="c0"><span class="c1">&#36825;&#37324;&#22312;CAS&#20043;&#21069;&#20570;&#20102;&#19968;&#20010;&#35835;&#21462;&#25506;&#27979;&#20248;&#21270;&#12290;&#22240;&#20026;CAS&#25805;&#20316;&#26080;&#35770;&#26159;&#21542;&#25104;&#21151;&#37117;&#20250;&#20135;&#29983;&#20026;&#20102;&#20445;&#35777;cache coherence&#32780;&#20135;&#29983;&#30340;message&#65292;&#38477;&#20302;&#24615;&#33021;&#12290;&#36825;&#37324;&#21482;&#26377;&#25506;&#27979;&#25104;&#21151;&#20043;&#21518;&#25165;&#20250;&#36827;&#34892;CAS&#25805;&#20316;&#65292;&#36827;&#32780;&#25552;&#21319;&#24615;&#33021;&#12290;</span></p><p class="c0"><span class="c1">5. ticketlock</span></p><p class="c0"><span class="c1">&#20026;&#20102;&#35299;&#20915;&#20844;&#24179;&#24615;&#30340;&#38382;&#39064;&#65292;&#24819;&#20102;&#19968;&#20010;&#21150;&#27861;&#65292;&#31867;&#20284;&#38134;&#34892;&#26381;&#21153;&#65292;&#22823;&#23478;&#36827;&#26469;&#20808;&#21435;&#26426;&#22120;&#25343;&#19968;&#20010;&#21495;&#30721;&#28982;&#21518;&#36825;&#20010;&#21495;&#30721;&#33258;&#22686;&#65292;&#26381;&#21153;&#21488;&#25353;&#29031;&#21478;&#19968;&#20010;&#21495;&#30721;&#21483;&#21495;&#65292;&#22823;&#23478;&#25343;&#21495;&#20043;&#21518;&#20840;&#37096;&#26597;&#30475;&#26381;&#21153;&#21488;&#65292;&#21040;&#20102;&#33258;&#24049;&#23601;&#21435;&#25509;&#21463;&#26381;&#21153;&#65292;&#26381;&#21153;&#23436;&#25104;&#20043;&#21518;&#36208;&#20986;&#26381;&#21153;&#21488;&#65292;&#26381;&#21153;&#21488;&#23558;&#33258;&#24049;&#30340;&#21495;&#30721;&#33258;&#22686;&#32487;&#32493;&#21483;&#19979;&#19968;&#20010;&#20154;&#12290;</span></p><p class="c0"><span class="c1">&#19979;&#38754;&#21015;&#20986;&#20856;&#22411;&#20195;&#30721;&#65306;</span></p><p class="c0"><span class="c1">class TicketSpinLock {</span></p><p class="c0"><span class="c1">public:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void lock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t my_id = FETCH_AND_ADD(&amp;next_id_, 1);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (ATOMIC_LOAD(&amp;service_id_) != my_id) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PAUSE();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void unlock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ADD_AND_FETCH(&amp;service_id_, 1);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">private:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t next_id_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t service_id_;</span></p><p class="c0"><span class="c1">};</span></p><p class="c0"><span class="c1">&#36825;&#37324;&#35299;&#20915;&#20102;&#20844;&#24179;&#24615;&#30340;&#38382;&#39064;&#12290;&#20294;scale&#33021;&#21147;&#36739;&#24046;&#65292;&#22240;&#20026;&#22823;&#23478;&#20173;&#28982;&#37117;spin&#22312;&#21516;&#19968;&#20010;service_id_&#21464;&#37327;&#19978;&#65292;&#24403;&#26576;&#20010;&#32447;&#31243;&#37322;&#25918;&#38145;&#20043;&#21518;&#65292;&#22240;&#20026;service_id_&#26356;&#26032;&#65292;&#20026;&#20102;&#20445;&#35777;cache coherence&#65292;&#38656;&#35201;&#23558;&#27599;&#20010;core&#19978;service_id_&#23545;&#24212;&#30340;cacheline&#32473;invalid&#25481;&#65292;&#28982;&#21518;&#25152;&#26377;&#31561;&#38145;&#30340;&#32447;&#31243;&#37117;&#20250;&#36890;&#36807;&#24635;&#32447;&#35835;&#21462;&#26032;&#20540;&#36896;&#25104;bus traffic&#65292;&#22312;&#22823;&#22810;&#25968;&#20307;&#31995;&#32467;&#26500;&#20013;&#29978;&#33267;&#34987;&#39034;&#24207;&#25191;&#34892;&#65292;&#25343;&#38145;&#26102;&#38388;&#27491;&#27604;&#20110;&#31561;&#38145;&#32447;&#31243;&#25968;&#30446;&#12290;</span></p><p class="c0"><span class="c1">6. mcslock</span></p><p class="c0"><span class="c1">mcslock&#32500;&#25252;&#20102;&#19968;&#20010;&#31561;&#38145;&#32447;&#31243;&#38431;&#21015;&#12290;&#36890;&#36807;&#27599;&#20010;&#31561;&#38145;&#32447;&#31243;spin&#22312;&#33258;&#24049;&#30340;tls&#21464;&#37327;&#19978;&#31561;&#24453;&#36890;&#30693;&#65292;&#22240;&#20026;&#20182;&#20204;&#19981;&#34987;&#22810;&#26680;&#20849;&#20139;&#65292;&#25552;&#21319;scala&#33021;&#21147;&#12290;</span></p><p class="c0"><span class="c1">struct MCSNode {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; bool waiting_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; MCSNode *next_;</span></p><p class="c0"><span class="c1">};</span></p><p class="c0"><span class="c1">class MCSSpinLock {</span></p><p class="c0"><span class="c1">public:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void lock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; MCSNode *tls_node = get_tls_node();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tls_node-&gt;next_ = nullptr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; MCSNode *prev_gnode = ATOMIC_EXCHANGE(&amp;gnode_, tls_node);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (prev_gnode == nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tls_node-&gt;waiting_ = true;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; COMPILER_BARRIER();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; prev_gnode-&gt;next_ = tls_node;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (ATOMIC_LOAD(&amp;tls_node-&gt;waiting_)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PAUSE();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void unlock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; MEM_BARRIER();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; MCSNode *tls_node = get_tls_node();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (tls_node-&gt;next_==nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (CAS(&amp;gnode_, tls_node, nullptr)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (!ATOMIC_LOAD(&amp;tls_node-&gt;next_)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PAUSE();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tls_node-&gt;next_-&gt;waiting_ = false;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">private:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; MCSNode* gnode_ = nullptr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; MCSNode *get_tls_node() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; static __thread MCSNode tls_node;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return &amp;tls_node;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">};</span></p><p class="c0"><span class="c1">&#20854;&#20013;gnode_&#22987;&#32456;&#25351;&#21521;&#38142;&#34920;&#30340;&#23614;&#31471;&#12290;</span></p><p class="c0"><span class="c1">7. rwlock</span></p><p class="c0"><span class="c1">&#35835;&#20889;&#38145;&#65292;&#23558;&#19968;&#20010;&#21407;&#23376;&#21464;&#37327;&#25286;&#25104;&#19977;&#37096;&#20998;&#65292;&#21152;&#35835;&#38145;&#27425;&#25968;&#65292;&#26159;&#21542;&#21152;&#20889;&#38145;&#65292;&#26159;&#21542;&#26377;&#20889;&#38145;&#22312;&#31561;&#24453;&#12290;&#26159;&#21542;&#26377;&#20889;&#38145;&#22312;&#31561;&#24453;&#26159;&#20026;&#20102;&#38450;&#27490;&#20889;&#32773;&#39269;&#39295;&#32780;&#35774;&#32622;&#30340;&#12290;&#19979;&#38754;&#26159;&#20855;&#20307;&#23454;&#29616;&#65306;</span></p><p class="c0"><span class="c1">class RWSpinLock {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; struct Atomic {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; union {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64_t v_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; struct {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64_t r_cnt_ :62;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64_t w_pending_ :1;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64_t w_flag_ :1;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; };</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Atomic() :</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v_(0) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0"><span class="c1">public:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void rLock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (true) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Atomic old_v = ATOMIC_LOAD(&amp;atomic_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Atomic new_v = old_v;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_v.r_cnt_++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (old_v.w_flag_</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; == 0&amp;&amp; old_v.w_pending_ == 0 &amp;&amp; CAS(&amp;atomic_.v_, old_v.v_, new_v.v_)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PAUSE();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void rUnLock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ADD_AND_FETCH(&amp;atomic_.v_, -1);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void wLock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (true) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Atomic old_v = ATOMIC_LOAD(&amp;atomic_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Atomic new_v = old_v;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bool pending = false;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (old_v.r_cnt_ != 0 || old_v.w_flag_ != 0) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_v.w_pending_ = 1;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending = true;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_v.w_flag_ = 1;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_v.w_pending_ = 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (CAS(&amp;atomic_.v_, old_v.v_, new_v.v_)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!pending) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PAUSE();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void wUnLock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; COMPILER_BARRIER();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; atomic_.w_flag_ = 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">private:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Atomic atomic_;</span></p><p class="c0"><span class="c1">};</span></p><p class="c0"><span class="c1">&#21152;&#35835;&#38145;&#26102;&#38656;&#35201;&#27809;&#26377;&#20889;&#38145;&#21152;&#38145;&#24182;&#19988;&#27809;&#26377;&#20889;&#38145;&#31561;&#24453;&#65292;&#28385;&#36275;&#21017;&#23558;&#21152;&#35835;&#38145;&#27425;&#25968;&#21152;1&#65292;&#19981;&#28385;&#36275;&#21017;&#24490;&#29615;&#31561;&#24453;&#12290;&#35299;&#35835;&#38145;&#26102;&#20165;&#20165;&#23545;&#21152;&#35835;&#38145;&#27425;&#25968;&#20943;1&#12290;&#21152;&#20889;&#38145;&#26102;&#21028;&#26029;&#26159;&#21542;&#26377;&#20154;&#25345;&#26377;&#35835;&#20889;&#38145;&#65292;&#22914;&#26524;&#26377;&#21017;&#23558;&#20889;&#32773;&#31561;&#24453;&#35774;&#32622;&#20026;&#30495;&#65292;&#21542;&#21017;&#23558;&#20889;&#38145;&#21152;&#38145;&#24182;&#19988;&#23558;&#20889;&#32773;&#31561;&#24453;&#35774;&#32622;&#20026;&#20551;&#12290;&#35299;&#20889;&#38145;&#26102;&#20165;&#20165;&#23545;&#26631;&#24535;&#20301;&#35774;&#32622;&#20026;&#20551;&#12290;&#20026;&#20102;&#35835;&#38145;&#21644;&#20889;&#38145;&#20043;&#38388;&#19982;&#20889;&#38145;&#21644;&#20889;&#38145;&#20043;&#38388;&#30340;&#20844;&#24179;&#24615;&#21487;&#20197;&#20351;&#29992;mcslock&#31561;spinlock&#26469;&#20445;&#35777;&#12290;&#23545;&#20110;&#22810;&#20889;&#30340;&#35835;&#20889;&#38145;&#21487;&#20197;&#20248;&#21270;&#20026;&#27599;&#20010;&#32447;&#31243;&#19968;&#20010;&#35835;&#20889;&#38145;&#65292;&#35835;&#25805;&#20316;CAS&#25805;&#20316;&#20114;&#19981;&#24433;&#21709;&#65292;&#38477;&#20302;bus traffic&#65292;&#25343;&#20889;&#38145;&#38656;&#35201;&#36941;&#21382;&#25152;&#26377;&#32447;&#31243;&#25343;&#20889;&#38145;&#12290;</span></p><p class="c0"><span class="c1">8. sequencelock</span></p><p class="c0"><span class="c1">&#20174;&#19978;&#21487;&#30693;&#65292;&#35835;&#20889;&#38145;&#22312;&#35835;&#32773;&#38271;&#26399;&#25345;&#26377;&#38145;&#30340;&#24773;&#20917;&#19979;&#36824;&#26159;&#25343;&#19981;&#21040;&#38145;&#65292;&#20026;&#20102;&#36991;&#20813;&#36825;&#31181;&#24773;&#20917;&#65292;&#25105;&#20204;&#38656;&#35201;&#20889;&#32773;&#22312;&#35835;&#32773;&#25345;&#26377;&#38145;&#30340;&#26102;&#20505;&#36827;&#34892;&#25250;&#21344;&#65292;sequencelock&#23601;&#21487;&#20197;&#35299;&#20915;&#36825;&#20010;&#38382;&#39064;&#12290;&#23454;&#29616;&#22914;&#19979;&#65306;</span></p><p class="c0"><span class="c1">class SequenceLock {</span></p><p class="c0"><span class="c1">private:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t seq_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; std::mutex mu_;</span></p><p class="c0"><span class="c1">public:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; SequenceLock() :</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_(0) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void wLock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; mu_.lock();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; seq_++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; COMPILER_BARRIER();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void wUnLock() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; COMPILER_BARRIER();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; seq_++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; mu_.unlock();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t rBegin() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t seq = 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (true) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq = ATOMIC_LOAD(&amp;seq_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!(seq &amp; 1)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return seq;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; bool rSuccess(uint64_t seq) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; MEM_BARRIER();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return ATOMIC_LOAD(&amp;seq_) == seq;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">};</span></p><p class="c0"><span class="c1">&#20889;&#32773;&#20043;&#38388;&#36890;&#36807;&#20114;&#26021;&#38145;&#20445;&#25345;&#20114;&#26021;&#65292;&#24403;&#20889;&#32773;&#20020;&#30028;&#21306;&#26102;&#20854;sequence&#21495;&#20026;&#22855;&#25968;&#65292;&#21542;&#21017;&#20026;&#20598;&#25968;&#12290;&#35835;&#32773;&#26681;&#25454;&#21462;&#21040;&#30340;sequence&#21495;&#30340;&#22855;&#20598;&#24615;&#20915;&#23450;&#26159;&#21542;&#21487;&#20197;&#36827;&#20837;&#20020;&#30028;&#21306;&#65292;&#22312;&#36864;&#20986;&#20020;&#30028;&#21306;&#26102;&#26816;&#26597;&#24403;&#21069;&#30340;sequence&#21495;&#21644;&#36827;&#20837;&#20020;&#30028;&#21306;&#26102;&#30340;sequence&#21495;&#26159;&#21542;&#19968;&#33268;&#65292;&#22914;&#26524;&#19968;&#33268;&#21017;&#25104;&#21151;&#65292;&#21542;&#21017;&#22833;&#36133;&#65292;&#38656;&#35201;&#25972;&#20010;&#25512;&#32763;&#37325;&#26469;&#12290;</span></p><p class="c0"><span class="c1">9. hazardpointer</span></p><p class="c0"><span class="c1">&#20026;&#20102;&#38450;&#27490;free&#20854;&#20182;&#32447;&#31243;&#27491;&#22312;&#20351;&#29992;&#30340;&#23545;&#35937;&#65292;&#24182;&#36991;&#20813;&#20986;&#29616;ABA&#38382;&#39064;&#65292;&#24341;&#20837;&#20102;hazardpointer&#12290;&#27599;&#19968;&#20010;&#32447;&#31243;&#32500;&#25252;&#19968;&#20010;&#33258;&#24049;&#30340;use_list&#21644;retire_list&#12290;&#20854;&#20013;retire_list&#20165;&#30001;&#33258;&#24049;&#35835;&#20889;&#65292;&#24590;&#20040;&#23454;&#29616;&#37117;&#34892;&#12290;use_list&#34987;&#33258;&#24049;&#35835;&#20889;&#65292;&#34987;&#20854;&#20182;&#32447;&#31243;&#35835;&#21462;&#65292;&#22240;&#27492;&#21482;&#38656;&#35201;&#23454;&#29616;&#19981;&#25903;&#25345;&#21024;&#38500;&#30340;&#19968;&#20010;&#21333;&#20889;&#32773;&#22810;&#35835;&#32773;&#24182;&#21457;&#30340;&#21333;&#38142;&#34920;&#23601;&#21487;&#20197;&#20102;&#12290;&#20445;&#25252;&#23545;&#35937;&#26102;&#35843;&#29992;acquire&#23558;&#20854;&#25351;&#38024;&#25918;&#20837;&#26412;&#32447;&#31243;&#30340;use_list&#65292;&#20351;&#29992;&#23436;&#20102;&#20043;&#21518;&#35843;&#29992;release&#23558;&#20854;&#25351;&#38024;&#20174;&#26412;&#32447;&#31243;&#30340;use_list&#20013;&#21024;&#38500;&#12290;&#24403;&#23545;&#35937;&#34987;&#36923;&#36753;&#21024;&#38500;&#26412;&#32447;&#31243;&#27809;&#20154;&#24341;&#29992;&#20043;&#21518;&#35843;&#29992;retire&#23558;&#20854;&#25351;&#38024;&#25918;&#20837;&#26412;&#32447;&#31243;&#30340;retire_list&#12290;&#27599;&#19968;&#20010;&#32447;&#31243;&#36127;&#36131;&#37322;&#25918;&#33258;&#24049;retire_list&#20013;&#30340;&#23545;&#35937;&#65292;&#24403;&#38656;&#35201;&#37322;&#25918;&#26102;&#35843;&#29992;reclaim&#65292;&#23427;&#25195;&#25551;&#33258;&#24049;&#30340;retire_list&#20013;&#30340;&#27599;&#19968;&#20010;&#25351;&#38024;&#65292;&#22914;&#26524;&#23427;&#19981;&#20986;&#29616;&#22312;&#20854;&#20182;&#32447;&#31243;&#30340;use_list&#21017;&#37322;&#25918;&#23427;&#23545;&#24212;&#23545;&#35937;&#30340;&#20869;&#23384;&#65292;&#24182;&#23558;&#20854;&#20174;retire_list&#20013;&#21024;&#38500;&#12290;</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;<br>class HazardPointer {<br>private:<br> &nbsp; &nbsp;struct HazardNode {<br> &nbsp; &nbsp; &nbsp; &nbsp;T *p_;<br> &nbsp; &nbsp; &nbsp; &nbsp;HazardNode *next_;<br> &nbsp; &nbsp; &nbsp; &nbsp;HazardNode() :<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p_(nullptr), next_(nullptr) {<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;HazardNode(T *p, HazardNode *next) :<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p_(p), next_(next) {<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;};<br> &nbsp; &nbsp;struct HazardList {<br> &nbsp; &nbsp; &nbsp; &nbsp;uint64_t len_;<br> &nbsp; &nbsp; &nbsp; &nbsp;uint64_t cap_;<br> &nbsp; &nbsp; &nbsp; &nbsp;HazardNode list_;<br> &nbsp; &nbsp; &nbsp; &nbsp;HazardList() :<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;len_(0), cap_(0) {<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}CACHE_ALIGNED;<br>public:<br> &nbsp; &nbsp;int acquire(T *p, int thread_id);<br> &nbsp; &nbsp;int release(T *p, int thread_id);<br> &nbsp; &nbsp;int retire(T *p, int thread_id);<br> &nbsp; &nbsp;int reclaim(int thread_id);<br> &nbsp; &nbsp;int help(HazardList *list, T *p, int thread_id);<br>private:<br> &nbsp; &nbsp;static const uint64_t MAX_THREAD_NUM = 10;<br> &nbsp; &nbsp;static const uint64_t MIN_LEN_TO_RECLAIM = 10;<br> &nbsp; &nbsp;HazardList use_list_[MAX_THREAD_NUM];<br> &nbsp; &nbsp;HazardList retire_list_[MAX_THREAD_NUM];<br>};<br>template&lt;typename T&gt;<br>int HazardPointer&lt;T&gt;::acquire(T *p, int thread_id) {<br> &nbsp; &nbsp;return help(use_list_, p, thread_id);<br>}<br>template&lt;typename T&gt;<br>int HazardPointer&lt;T&gt;::release(T *p, int thread_id) {<br> &nbsp; &nbsp;for (HazardNode *node = &amp;use_list_[thread_id].list_; node != nullptr; node =<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node-&gt;next_) {<br> &nbsp; &nbsp; &nbsp; &nbsp;if (node-&gt;p_ == p) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node-&gt;p_ = nullptr;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;use_list_[thread_id].len_--;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 0;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;return -1;<br>}<br>template&lt;typename T&gt;<br>int HazardPointer&lt;T&gt;::retire(T *p, int thread_id) {<br> &nbsp; &nbsp;return help(retire_list_, p, thread_id);<br>}<br>template&lt;typename T&gt;<br>int HazardPointer&lt;T&gt;::reclaim(int thread_id) {<br> &nbsp; &nbsp;if (retire_list_[thread_id].len_ &lt; MIN_LEN_TO_RECLAIM) {<br> &nbsp; &nbsp; &nbsp; &nbsp;return 0;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;for (HazardNode *retire_node = &amp;retire_list_[thread_id].list_;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;retire_node != nullptr; retire_node = retire_node-&gt;next_) {<br> &nbsp; &nbsp; &nbsp; &nbsp;if (retire_node-&gt;p_ == nullptr) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;bool found = false;<br> &nbsp; &nbsp; &nbsp; &nbsp;for (int other_thread_id = 0; other_thread_id &lt; MAX_THREAD_NUM;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;other_thread_id++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (thread_id == other_thread_id) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (HazardNode *other_use_node = &amp;use_list_[other_thread_id].list_;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;other_use_node != nullptr;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;other_use_node = other_use_node-&gt;next_) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (other_use_node-&gt;p_ == retire_node-&gt;p_) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;found = true;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (found) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;if (!found) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;retire_list_[thread_id].len_--;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;delete retire_node-&gt;p_;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;retire_node-&gt;p_ = nullptr;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;return 0;<br>}<br>template&lt;typename T&gt;<br>int HazardPointer&lt;T&gt;::help(HazardList *list, T *p, int thread_id) {<br> &nbsp; &nbsp;if (p == nullptr) {<br> &nbsp; &nbsp; &nbsp; &nbsp;return 0;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;bool found = false;<br> &nbsp; &nbsp;HazardNode *empty_node = nullptr;<br> &nbsp; &nbsp;for (empty_node = &amp;list[thread_id].list_; empty_node != nullptr;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;empty_node = empty_node-&gt;next_) {<br> &nbsp; &nbsp; &nbsp; &nbsp;if (empty_node-&gt;p_ == nullptr) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;found = true;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;if (found) {<br> &nbsp; &nbsp; &nbsp; &nbsp;empty_node-&gt;p_ = p;<br> &nbsp; &nbsp; &nbsp; &nbsp;list[thread_id].len_++;<br> &nbsp; &nbsp;} else {<br> &nbsp; &nbsp; &nbsp; &nbsp;HazardNode *new_node = new HazardNode(p, list[thread_id].list_.next_);<br> &nbsp; &nbsp; &nbsp; &nbsp;MEM_BARRIER();<br> &nbsp; &nbsp; &nbsp; &nbsp;list[thread_id].list_.next_ = new_node;<br> &nbsp; &nbsp; &nbsp; &nbsp;list[thread_id].len_++;<br> &nbsp; &nbsp; &nbsp; &nbsp;list[thread_id].cap_++;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;return 0;<br>}</span></p><p class="c0"><span class="c1">10. hazardversion</span></p><p class="c0"><span class="c1">&#22240;&#20026;&#35201;&#25214;&#20986;&#21738;&#20123;&#25351;&#38024;&#38656;&#35201;&#34987;&#20445;&#25252;&#38750;&#24120;&#22686;&#21152;&#24515;&#26234;&#36127;&#25285;&#65292;&#22240;&#27492;&#24341;&#20837;hazardversion&#12290;&#23427;&#25552;&#20379;&#31616;&#20415;&#30340;acquire&#12289;release&#21644;retire&#25509;&#21475;&#65292;&#20351;&#29992;&#36215;&#26469;&#38750;&#24120;&#26041;&#20415;&#12290;&#27599;&#20010;&#32447;&#31243;&#32500;&#25252;&#33258;&#24049;&#30340;retire_list&#21644;version&#65292;&#20840;&#23616;&#23384;&#19968;&#20010;version&#65292;&#27492;&#22806;retire_list&#20013;&#27599;&#19968;&#20010;&#20803;&#32032;&#38500;&#20102;&#24453;&#37322;&#25918;&#30340;&#25351;&#38024;&#22806;&#20063;&#26377;&#19968;&#20010;version&#12290;&#24403;&#35843;&#29992;acquire&#26102;&#65292;&#23558;&#20840;&#23616;&#29256;&#26412;&#21495;&#35774;&#32622;&#32473;&#33258;&#24049;&#12290;&#24403;&#35843;&#29992;release&#26102;&#65292;&#23558;&#33258;&#24049;&#30340;&#29256;&#26412;&#32622;&#20026;max&#65292;&#24182;&#21028;&#26029;&#33258;&#24049;&#30340;retire_list&#26159;&#21542;&#22826;&#38271;&#38656;&#35201;reclaim&#21644;&#25152;&#26377;&#30340;retire_list&#20043;&#21644;&#26159;&#21542;&#22826;&#38271;&#38656;&#35201;reclaim&#12290;retire&#25805;&#20316;&#23558;&#20840;&#23616;&#29256;&#26412;&#21152;1&#21518;&#36171;&#20104;retire&#20803;&#32032;&#65292;&#24182;&#23558;&#20854;&#21152;&#20837;retire_list&#12290;&#23545;&#20110;&#33258;&#24049;&#30340;reclaim&#65292;&#39318;&#20808;&#33719;&#24471;&#25152;&#26377;&#32447;&#31243;&#30340;&#26368;&#23567;&#29256;&#26412;&#65292;&#28982;&#21518;&#39318;&#20808;&#23558;&#25972;&#20010;retire_list&#38431;&#21015;CAS&#21040;&#23616;&#37096;&#65292;&#28982;&#21518;&#22312;&#23616;&#37096;&#36941;&#21382;&#21024;&#38500;&#37322;&#25918;&#29256;&#26412;&#21495;&#23567;&#20110;&#31561;&#20110;&#25152;&#26377;&#32447;&#31243;&#26368;&#23567;&#29256;&#26412;&#30340;&#20803;&#32032;&#65292;&#26368;&#21518;&#23558;&#21097;&#19979;&#30340;&#20803;&#32032;&#21015;&#34920;CAS&#21040;&#38142;&#34920;&#22836;&#37096;&#12290;&#23545;&#20110;&#20840;&#23616;&#30340;reclaim&#65292;&#39318;&#20808;&#33719;&#24471;&#25152;&#26377;&#32447;&#31243;&#30340;&#26368;&#23567;&#29256;&#26412;&#65292;&#28982;&#21518;&#36941;&#21382;&#25152;&#26377;&#32447;&#31243;&#30340;retire_list&#65292;&#23558;&#20854;CAS&#21040;&#23616;&#37096;&#65292;&#28982;&#21518;&#22312;&#23616;&#37096;&#36941;&#21382;&#21024;&#38500;&#37322;&#25918;&#29256;&#26412;&#21495;&#23567;&#20110;&#31561;&#20110;&#25152;&#26377;&#32447;&#31243;&#26368;&#23567;&#29256;&#26412;&#30340;&#20803;&#32032;&#65292;&#26368;&#21518;&#23558;&#21097;&#19979;&#30340;&#20803;&#32032;&#21015;&#34920;CAS&#21040;&#33258;&#24049;retire_list&#30340;&#38142;&#34920;&#22836;&#37096;&#12290;&#30001;&#20110;&#21482;&#26377;retire_list&#21482;&#26377;&#33258;&#24049;&#33021;&#28155;&#21152;&#65292;&#20854;&#20182;&#32447;&#31243;&#21482;&#33021;&#23558;&#20854;&#28165;&#31354;&#65292;&#22240;&#27492;&#19981;&#20250;&#20986;&#29616;ABA&#38382;&#39064;&#12290;&#20026;&#20160;&#20040;&#26159;&#23567;&#20110;&#31561;&#20110;&#65311;&#39318;&#20808;&#36923;&#36753;&#21024;&#38500;&#65292;&#28982;&#21518;&#29256;&#26412;&#21495;&#21152;1&#36171;&#20104;retire&#33410;&#28857;&#65292;&#20294;&#26159;&#25343;&#21040;&#22686;&#21152;&#20043;&#21518;&#29256;&#26412;&#21495;&#30340;&#26159;&#19981;&#21487;&#33021;&#20351;&#29992;retire&#33410;&#28857;&#20869;&#23384;&#30340;&#65292;&#22240;&#20026;&#23427;&#24050;&#32463;&#34987;&#36923;&#36753;&#21024;&#38500;&#12290;</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">class HazardVersion {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; struct Node {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Node *next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; T *data_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t version_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Node(T *data);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ~Node();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; struct ThreadStore {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t version_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t seq_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Node *retire_list_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t retire_list_len_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint16_t tid_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; bool enabled_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t last_reclaim_version_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ThreadStore *next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ThreadStore();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ~ThreadStore();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t acquire(const uint64_t version, const uint16_t tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; void release(const uint64_t tid, uint64_t &amp;handle);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; void add_node(uint64_t version, Node *node);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t reclaim(const uint64_t version, ThreadStore *node_receiver);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; void add_nodes(Node *head, Node *tail, const int64_t cnt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0"><span class="c1">public:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void reclaim(uint16_t tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t acquire(uint16_t tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void retire(uint16_t tid, T *p);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void release(uint16_t tid, uint64_t handle);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; HazardVersion() :</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_num_to_reclaim_(64), threads_list_(nullptr), threads_cnt_(0), min_version_(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0), min_version_ts_(0), min_version_cache_interval_(200000), version_(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0), retire_cnt_(0) {</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">private:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int64_t tv_to_usec(const timeval &amp;tv);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int64_t now();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t get_min_version(bool force);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore* get_thread_store(int16_t tid) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (tid &gt; MAX_THREAD_CNT) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(false);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ThreadStore *ts = &amp;threads_[tid];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (!ts-&gt;enabled_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threads_lock_.lock();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!ts-&gt;enabled_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts-&gt;tid_ = tid;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts-&gt;version_ = UINT64_MAX;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts-&gt;next_ = threads_list_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ATOMIC_STORE(&amp;threads_list_, ts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADD_AND_FETCH(&amp;threads_cnt_, 1);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ts-&gt;enabled_ = true;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; threads_lock_.unlock();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return ts;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; const static uint16_t MAX_THREAD_CNT = 10;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t min_num_to_reclaim_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; SimpleSpinLock threads_lock_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore threads_[MAX_THREAD_CNT];</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore *threads_list_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t threads_cnt_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t min_version_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int64_t min_version_ts_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int64_t min_version_cache_interval_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t version_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t retire_cnt_;</span></p><p class="c0"><span class="c1">};</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">HazardVersion&lt;T&gt;::Node::Node(T *data) :</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; next_(nullptr), version_(UINT64_MAX), data_(data) {</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">HazardVersion&lt;T&gt;::Node::~Node() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; delete data_;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">HazardVersion&lt;T&gt;::ThreadStore::ThreadStore() :</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; enabled_(false), tid_(0), last_reclaim_version_(0), seq_(0), version_(</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0), retire_list_(nullptr), retire_list_len_(0), next_(nullptr) {</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">HazardVersion&lt;T&gt;::ThreadStore::~ThreadStore() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while (retire_list_ != nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Node *retire_node = retire_list_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; retire_list_ = retire_list_-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; delete retire_node;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">uint64_t HazardVersion&lt;T&gt;::ThreadStore::acquire(const uint64_t version,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; const uint16_t tid) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if (version_ != UINT64_MAX || tid_ != tid) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; assert(false);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; version_ = version;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; return seq_;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">void HazardVersion&lt;T&gt;::ThreadStore::release(const uint64_t tid,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t &amp;handle) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if (seq_ != handle || tid != tid_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; assert(false);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; version_ = UINT64_MAX;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; seq_++;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">void HazardVersion&lt;T&gt;::ThreadStore::add_nodes(Node *head, Node *tail,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; const int64_t cnt) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if (cnt &gt; 0) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Node *curr = ATOMIC_LOAD(&amp;retire_list_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Node *old = curr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tail-&gt;next_ = old;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (old != (curr = CAS_RET_VAL(&amp;retire_list_, old, head))) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = curr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tail-&gt;next_ = old;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ADD_AND_FETCH(&amp;retire_list_len_, cnt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">void HazardVersion&lt;T&gt;::ThreadStore::add_node(uint64_t version, Node *node) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; node-&gt;version_ = version;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; add_nodes(node, node, 1);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">uint64_t HazardVersion&lt;T&gt;::ThreadStore::reclaim(const uint64_t version,</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ThreadStore *node_receiver) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if (last_reclaim_version_ == version) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; last_reclaim_version_ = version;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Node *curr = ATOMIC_LOAD(&amp;retire_list_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Node *old = curr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while (old != (curr = CAS_RET_VAL(&amp;retire_list_, old, nullptr))) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; old = curr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Node *list2free = nullptr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t move_cnt = 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t free_cnt = 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Node dummy(nullptr);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; dummy.next_ = curr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Node *iter = &amp;dummy;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while (iter-&gt;next_ != nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (iter-&gt;next_-&gt;version_ &lt;= version) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_cnt++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *node2free = iter-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter-&gt;next_ = iter-&gt;next_-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; node2free-&gt;next_ = list2free;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list2free = node2free;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; } else {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; move_cnt++;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter = iter-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; node_receiver-&gt;add_nodes(dummy.next_, iter, move_cnt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ADD_AND_FETCH(&amp;retire_list_len_, -(move_cnt + free_cnt));</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while (list2free != nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Node *node2free = list2free;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; list2free = list2free-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; delete node2free;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; return free_cnt;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">int64_t HazardVersion&lt;T&gt;::tv_to_usec(const timeval &amp;tv) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return (((int64_t) tv.tv_sec) * 1000000 + (int64_t) tv.tv_usec);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">int64_t HazardVersion&lt;T&gt;::now() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; struct timeval tv;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; gettimeofday(&amp;tv, nullptr);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; return tv_to_usec(tv);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">uint64_t HazardVersion&lt;T&gt;::get_min_version(bool force) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t ret = 0;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int64_t now_ts = now();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if (!force &amp;&amp; (ret = ATOMIC_LOAD(&amp;min_version_)) != 0</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; ATOMIC_LOAD(&amp;min_version_ts_) + min_version_cache_interval_</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt; now_ts) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return ret;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ret = ATOMIC_LOAD(&amp;version_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore *iter = ATOMIC_LOAD(&amp;threads_list_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while (iter != nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t ts_version = iter-&gt;version_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (ret &gt; ts_version) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = ts_version;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; iter = iter-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ATOMIC_STORE(&amp;min_version_, ret);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ATOMIC_STORE(&amp;min_version_ts_, now_ts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; return ret;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">void HazardVersion&lt;T&gt;::reclaim(uint16_t tid) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore *ts = get_thread_store(tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t min_version = get_min_version(true);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; int64_t reclaim_cnt = ts-&gt;reclaim(min_version, ts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ADD_AND_FETCH(&amp;retire_cnt_, -reclaim_cnt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore *iter = ATOMIC_LOAD(&amp;threads_list_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; while (iter != nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (iter != ts) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reclaim_cnt = iter-&gt;reclaim(min_version, ts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADD_AND_FETCH(&amp;retire_cnt_, -reclaim_cnt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; iter = iter-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">uint64_t HazardVersion&lt;T&gt;::acquire(uint16_t tid) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore *ts = get_thread_store(tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t version = ATOMIC_LOAD(&amp;version_);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; uint64_t handle = ts-&gt;acquire(version, tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; return handle;</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">void HazardVersion&lt;T&gt;::retire(uint16_t tid, T *p) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Node *node = new Node(p);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore *ts = get_thread_store(tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ts-&gt;add_node(ADD_AND_FETCH(&amp;version_, 1), node);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ADD_AND_FETCH(&amp;retire_cnt_, 1);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">void HazardVersion&lt;T&gt;::release(uint16_t tid, uint64_t handle) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if (tid &gt; MAX_THREAD_CNT) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; assert(false);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ThreadStore *ts = get_thread_store(tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ts-&gt;release(tid, handle);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; if (ts-&gt;retire_list_len_ &gt; min_num_to_reclaim_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t min_version = get_min_version(false);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t reclaim_cnt = ts-&gt;reclaim(min_version, ts);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; ADD_AND_FETCH(&amp;retire_cnt_, -reclaim_cnt);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; } else if (ATOMIC_LOAD(&amp;retire_cnt_)</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt; ATOMIC_LOAD(&amp;threads_cnt_) * min_num_to_reclaim_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; reclaim(tid);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">}</span></p><p class="c0"><span class="c1">10. lock free queue</span></p><p class="c0"><span class="c1">&#25554;&#20837;&#38431;&#21015;&#25805;&#20316;&#65306;&#39318;&#20808;&#25343;&#21040;&#20840;&#23616;tail&#65292;&#28982;&#21518;&#25343;&#21040;&#23616;&#37096;tail&#30340;next&#12290;&#21028;&#26029;&#23616;&#37096;tail&#26159;&#21542;&#31561;&#20110;&#20840;&#23616;tail&#65292;&#22914;&#26524;&#19981;&#31561;&#21017;&#32487;&#32493;&#24490;&#29615;&#65292;&#22914;&#26524;&#31561;&#35828;&#26126;next&#26159;&#20840;&#23616;tail&#30340;next&#65292;&#21363;&#26377;&#25928;&#30340;&#65292;&#20854;&#23454;&#36825;&#27493;&#21487;&#26377;&#21487;&#26080;&#12290;&#22914;&#26524;next&#19981;&#20026;&#31354;&#35828;&#26126;&#23616;&#37096;tail&#19981;&#20877;&#26159;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#65292;&#23581;&#35797;&#21069;&#36827;&#20840;&#23616;tail&#24182;&#32487;&#32493;&#24490;&#29615;&#12290;&#23581;&#35797;&#20197;null&#21644;&#26032;&#20803;&#32032;CAS&#23616;&#37096;tail&#30340;next&#65292;&#23581;&#35797;&#21069;&#36827;&#20840;&#23616;tail&#24182;&#36339;&#20986;&#24490;&#29615;&#12290;</span></p><p class="c0"><span class="c1">&#31227;&#20986;&#38431;&#21015;&#25805;&#20316;&#65306;&#39318;&#20808;&#25343;&#21040;&#20840;&#23616;&#30340;head&#21644;&#20840;&#23616;&#30340;tail&#65292;&#28982;&#21518;&#25343;&#21040;&#23616;&#37096;head&#30340;next&#12290;&#21028;&#26029;&#23616;&#37096;head&#26159;&#21542;&#31561;&#20110;&#20840;&#23616;head&#65292;&#22914;&#26524;&#19981;&#31561;&#21017;&#32487;&#32493;&#24490;&#29615;&#65292;&#22914;&#26524;&#31561;&#35828;&#26126;next&#26159;&#20840;&#23616;head&#30340;next&#65292;&#21363;&#26377;&#25928;&#30340;&#65292;&#20854;&#23454;&#36825;&#27493;&#21487;&#26377;&#21487;&#26080;&#12290;&#22914;&#26524;next&#20026;&#31354;&#35828;&#26126;&#38431;&#21015;&#20026;&#31354;&#65292;&#36820;&#22238;&#31354;&#20540;&#12290;&#21028;&#26029;head&#26159;&#21542;&#31561;&#20110;tail&#65292;&#22914;&#26524;&#26159;&#35828;&#26126;&#38431;&#21015;&#19981;&#20026;&#31354;&#20294;&#26159;tail&#25351;&#38024;&#27809;&#33021;&#21450;&#26102;&#21069;&#36827;&#65292;&#23581;&#35797;&#21069;&#36827;&#20840;&#23616;tail&#24182;&#32487;&#32493;&#24490;&#29615;&#12290;&#25343;&#21040;next&#30340;&#25968;&#25454;&#65292;&#24182;&#23581;&#35797;&#21069;&#36827;head&#65292;&#22914;&#26524;&#22833;&#36133;&#21017;&#32487;&#32493;&#24490;&#29615;&#65292;&#22914;&#26524;&#25104;&#21151;&#21017;&#36820;&#22238;&#21462;&#21040;&#30340;&#25968;&#25454;&#12290;</span></p><p class="c0"><span class="c1">template&lt;typename T&gt;</span></p><p class="c0"><span class="c1">class ConcurrentQueueWithVersion {</span></p><p class="c0"><span class="c1">private:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; struct Item {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; T data_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Item *volatile next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Item(): next_(nullptr){}</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Item(T data, Item *next) : data_(data),</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_(next) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; };</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Item * volatile head_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Item * volatile tail_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; Item dummy_item_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; HazardVersion&lt;Item&gt; hv_;</span></p><p class="c0"><span class="c1">public:</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; ConcurrentQueueWithVersion() {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; head_ = &amp;dummy_item_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; tail_ = &amp;dummy_item_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; void enqueue(const T element, int thread_id) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Item *item = new Item(element, nullptr);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t handle = hv_.acquire(thread_id);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (true) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Item *tail = tail_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Item *next = tail-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tail != tail_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (next != nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAS(&amp;tail_, tail, next);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (CAS(&amp;tail-&gt;next_, nullptr, item)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAS(&amp;tail_, tail, item);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; hv_.release(thread_id, handle);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0 c3"><span class="c1"></span></p><p class="c0"><span class="c1">&nbsp; &nbsp; T dequeue(int thread_id) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Item *head = nullptr;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; T data;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; uint64_t handle = hv_.acquire(thread_id);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; while (true) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; head = head_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Item *tail = tail_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Item *next = head-&gt;next_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (head != head_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (next == nullptr) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hv_.release(thread_id, handle);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return T();</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (head == tail) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CAS(&amp;tail_, tail, next);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = next-&gt;data_;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (CAS(&amp;head_, head, next)) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; hv_.release(thread_id, handle);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (head != &amp;dummy_item_) {</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hv_.retire(thread_id, head);</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; return data;</span></p><p class="c0"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c1">};</span></p></body></html>